
buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.igormaznitsa:jcp:7.0.4'
    }
}

plugins {
    id 'java-library'
}

//apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'com.igormaznitsa.jcp'

group 'org.example'
version '1.0-SNAPSHOT'

mainClassName = 'java.HelloWorld'


java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}
sourceSets {
    java11 {
        java {
            srcDirs = ['build/jcp/java11']
        }
    }
}
dependencies {
    implementation 'org.codehaus.groovy:groovy-all:3.0.5'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
    java11Implementation files(sourceSets.main.output.classesDirs)
}

test {
    useJUnitPlatform()
}

jar {
    into('META-INF/versions/11') {
        from sourceSets.java11.output
    }
    manifest.attributes(
            'Multi-Release': 'true',
            'Main-Class': 'Main'
    )
    archiveBaseName = 'first'
}

tasks.named('compileJava11Java') {
    javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

task compileWithJava8 (type: com.igormaznitsa.jcp.gradle.JcpTask) {

    sourceSets.main.output.each { println it}
    println "executing compileWithJava8"

//        preprocess {

        sources = sourceSets.main.java.srcDirs
        allowWhitespaces = true
        eol = '\r\n'
        keepAttributes = true
        sourceEncoding = 'UTF-8'
        targetEncoding = 'UTF-8'
        ignoreMissingSources = false
        excludeExtensions = ['txt', 'xml']
        fileExtensions = ['java']
        unknownVarAsFalse = false
        dryRun = false
        verbose = true
        clearTarget = true
        careForLastEol = true
        keepComments = true
        excludeFolders = ['**/some1', '**/some2']
        //    configFiles = ['./configFile.txt']
        keepLines = true
        allowWhitespaces = true
        preserveIndents = true
        dontOverwriteSameContent = false
        vars = [isJava8: 'true']
        target = new File(project.buildDir, "jcp" + File.separatorChar + "java")

//        doLast{
//            println("Incoming preprocess files: " + preprocess.incomingFiles.size())
//            println("Resulted preprocess files: " + preprocess.outcomingFiles.size())
//        }

}

task compileWithJava11 (type: com.igormaznitsa.jcp.gradle.JcpTask) {


        println "executing compileWithJava11"
        println sourceSets.main.java.srcDirs

        sources = sourceSets.main.java.srcDirs
        allowWhitespaces = true
        eol = '\r\n'
        keepAttributes = true
        sourceEncoding = 'UTF-8'
        targetEncoding = 'UTF-8'
        ignoreMissingSources = false
        excludeExtensions = ['txt', 'xml']
        fileExtensions = ['java']
        unknownVarAsFalse = false
        dryRun = false
        verbose = true
        clearTarget = true
        careForLastEol = true
        keepComments = true
        excludeFolders = ['**/some1', '**/some2']
        //    configFiles = ['./configFile.txt']
        keepLines = true
        allowWhitespaces = true
        preserveIndents = true
        dontOverwriteSameContent = false
        vars = [isJava8: 'false']
        target = new File(project.buildDir, "jcp" + File.separatorChar + "java11")

    doLast{
        println("Incoming preprocess files: " + incomingFiles.size())
        println("Resulted preprocess files: " + outcomingFiles.size())
    }

}

task changeSourceFolder(){
    doLast{
        sourceSets.main.java.srcDirs = ["build/jcp/java"]

    }
}
import java.io.File;
import java.security.MessageDigest;
import java.nio.file.Files;
import java.nio.file.Paths;
task deleteDuplicatedFiles(){

    doLast {

        Set<String> directorySet = new TreeSet<>()

        // get all directories and stored them in alphabetically sorted order
        fileTree(dir: 'build/jcp').visit { FileVisitDetails fvd ->
            if(fvd.file.isDirectory()) {
                File f = new File(fvd.file.toString());
                // skip sub-folders
                if(!directorySet.contains(f.getParentFile())){
                    directorySet.add(fvd.file)
                }

            }
        }

        Map<String, String> fileMap = new HashMap<>()

        for(String directory : directorySet){

            fileTree(dir: directory).visit { FileVisitDetails fvd ->
                if(fvd.file.isFile()) {

                    byte[] fileContent = Files.readAllBytes(Paths.get(fvd.file.toString()));
                    byte[] hash = MessageDigest.getInstance("MD5").digest(fileContent);

                    if(fileMap.containsKey(fvd.getRelativePath())){
                        if(fileMap.get(fvd.getRelativePath()).equals(hash.toString())){
                            println ("found duplicated file: " + fvd.file)
                        }

                    }
                    else {
                        fileMap.put(fvd.getRelativePath(), hash.toString())
                    }
                }
            }
        }

    }

}

compileWithJava8.dependsOn(compileWithJava11)
deleteDuplicatedFiles.dependsOn compileWithJava8
changeSourceFolder.dependsOn deleteDuplicatedFiles
compileJava.dependsOn changeSourceFolder

// fix dependencies
// look at subproject gradle build

//compileJava.dependsOn preprocess




