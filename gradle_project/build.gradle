buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'com.igormaznitsa:jcp:7.0.4'
    }
}

plugins {
    id 'java-library'
}

//apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'com.igormaznitsa.jcp'

group 'org.example'
version '1.0-SNAPSHOT'

mainClassName = 'java.HelloWorld'
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(8))
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}
sourceSets {
    java11 {
        java {
            srcDirs = ['build/jcp/java11']
        }
    }
}
dependencies {
    implementation 'org.codehaus.groovy:groovy-all:3.0.5'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
    java11Implementation files(sourceSets.main.output.classesDirs)
}

test {
    useJUnitPlatform()
}

jar {
    into('META-INF/versions/11') {
        from sourceSets.java11.output
    }
    manifest.attributes(
            'Multi-Release': 'true',
            'Main-Class': 'Main'
    )
    archiveBaseName = 'first'
}

tasks.named('compileJava11Java') {
    javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

task compileWithJava8 (type: com.igormaznitsa.jcp.gradle.JcpTask) {

    println "executing compileWithJava"
    println sourceSets.main.java.srcDirs

//        preprocess {

        sources = sourceSets.main.java.srcDirs
//        allowWhitespaces = true
//        eol = '\r\n'
//        keepAttributes = true
//        sourceEncoding = 'UTF-8'
//        targetEncoding = 'UTF-8'
//        ignoreMissingSources = false
//        excludeExtensions = ['txt', 'xml']
//        fileExtensions = ['java']
//        unknownVarAsFalse = false
//        dryRun = false
//        verbose = true
//        clearTarget = true
//        careForLastEol = true
//        keepComments = true
//        excludeFolders = ['**/some1', '**/some2']
//        //    configFiles = ['./configFile.txt']
//        keepLines = true
//        allowWhitespaces = true
//        preserveIndents = true
//        dontOverwriteSameContent = false
        vars = [isJava8: 'true']
        target = new File(project.buildDir, "jcp" + File.separatorChar + "java")
        doLast{
            println("Incoming preprocess files: " + incomingFiles.size())
            println("Resulted preprocess files: " + outcomingFiles.size())
        }

}

task compileWithJava11 (type: com.igormaznitsa.jcp.gradle.JcpTask) {

        println "executing compileWithJava11"
        println sourceSets.main.java.srcDirs

        sources = sourceSets.main.java.srcDirs

//        allowWhitespaces = true
//        eol = '\r\n'
//        keepAttributes = true
//        sourceEncoding = 'UTF-8'
//        targetEncoding = 'UTF-8'
//        ignoreMissingSources = false
//        excludeExtensions = ['txt', 'xml']
//        fileExtensions = ['java']
//        unknownVarAsFalse = false
//        dryRun = false
//        verbose = true
//        clearTarget = true
//        careForLastEol = true
//        keepComments = true
//        excludeFolders = ['**/some1', '**/some2']
        //    configFiles = ['./configFile.txt']
//        keepLines = true
//        allowWhitespaces = true
//        preserveIndents = true
//        dontOverwriteSameContent = true
        vars = [isJava8: 'false']
        target = new File(project.buildDir, "jcp" + File.separatorChar + "java11")

    doLast{
        println("Incoming preprocess files: " + incomingFiles.size())
        println("Resulted preprocess files: " + outcomingFiles.size())
    }

}

task changeSourceFolder(){
    doLast{
        sourceSets.main.java.srcDirs = ["build/jcp/java"]
    }
}
import java.io.File;
import java.security.MessageDigest;
import java.nio.file.Files;
import java.nio.file.Paths;
task deleteDuplicatedFiles(){

    doLast {

        // get all directories just below the jcp directory
        File dir = new File("build/jcp")
        File[] directories = new File("build/jcp").listFiles()
        FileFilter fileFilter = new FileFilter() {
            public boolean accept(File file) {
                return file.isDirectory();
            }
        }
        directories = dir.listFiles(fileFilter);
        // stored the directories in alphabetical order
        Arrays.sort(directories)
//        println directories.toString()

        Map<String, String> fileMap = new HashMap<>()
        for(String directory : directories){

            fileTree(dir: directory).visit { FileVisitDetails fvd ->
                if(fvd.file.isFile()) {
                    // calculate the MD5 hash for the file
                    byte[] fileContent = Files.readAllBytes(Paths.get(fvd.file.toString()));
                    String relativePath = fvd.getRelativePath()
                    String hashString = MessageDigest.getInstance("MD5").digest(fileContent).toString();

                    if(fileMap.containsKey(relativePath)){
                        if(fileMap.get(relativePath).equals(hashString)){
                            println ("found duplicated file: " + fvd.file)
                            project.delete(files(fvd.file))
                        }
                    } else {
                        fileMap.put(relativePath, hashString)
                    }
                }
            }
        }
    }
}

compileWithJava8.dependsOn(compileWithJava11)
deleteDuplicatedFiles.dependsOn compileWithJava8
changeSourceFolder.dependsOn deleteDuplicatedFiles
compileJava.dependsOn changeSourceFolder

// fix dependencies
// look at subproject gradle build

//compileJava.dependsOn preprocess




